"""
Задание 1.
Реализуйте функции:
a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

import time


def get_run_time(func):
    def wrap(*args, **kwargs):
        start_time = time.time()
        func(*args, **kwargs)
        end_time = time.time() - start_time
        return end_time
    return wrap


test_list = []
test_dict = {}


# a)___________________________________________________________________________________________________________________
@get_run_time
def list_expand(test_list, amount_of_elements):
    for i in range(amount_of_elements):
        test_list.append(i)


@get_run_time
def dict_expand(test_dict, amount_of_elements):
    for i in range(amount_of_elements):
        test_dict[i] = i


print(list_expand(test_list, 100000), 'заполнение списка')  # Сложность: O(100000)
print(dict_expand(test_dict, 100000), 'заполнение словаря\n')  # Сложность: O(100000)
"""
Вывод: Список заполняется быстрее чем словарь. Потому что, при заполнение словаря выполняется еще и хеширование ключей.
"""


# b)___________________________________________________________________________________________________________________
@get_run_time
def get_list_item(test_list):
    for i in range(100000):
        el = test_list[i]


@get_run_time
def get_dict_item(test_dict):
    for i in range(100000):
        el = test_dict[i]


print(get_list_item(test_list), 'получение элемента списка')  # Сложность: O(100000)
print(get_dict_item(test_dict), 'получение элемента словаря\n')  # Сложность: O(100000)
"""
Вывод: Получить из списка элемент по индексу быстрее чем получать элемент из словаря по ключу.
Потому что при обращении к элементу словаря, ключ сначала хешируется, 
а потом проверяется есть ли элемент c таким хешом(ключом). 
"""


# c)___________________________________________________________________________________________________________________
@get_run_time
def del_list_item(test_list):
    for i in range(100000):
        el = test_list.pop()


@get_run_time
def del_dict_item(test_dict):
    for i in range(100000):
        el = test_dict.pop(i)


print(del_list_item(test_list), 'удаление элемента списка')  # Сложность: O(100000)
print(del_dict_item(test_dict), 'удаление элемента словаря')  # Сложность: O(100000)
"""
Вывод: Удалить элемент из списка не по индексу(методом pop()) быстрее чем удалить элемент из словаря по ключу.
Потому что при обращении к элементу словаря, ключ сначала хешируется и сравнивается с хешами из таблицы.
И при нахождении подобного удаляет его.
"""
